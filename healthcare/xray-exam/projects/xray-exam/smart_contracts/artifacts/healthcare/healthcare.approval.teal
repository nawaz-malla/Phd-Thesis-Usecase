#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock "locked" "" "e1" "e3" "e5" "e8" "e10" "e12" "e13" "e16" "e17" "e0" "e2" "e4" "e7" "e9" "e11" "e14" "e15" "e18" "patient" "radiology" "admin" "ward" "accepted" "appointment_id" "registration_confirmed" "e6" "medical_prescription" "request_id" "appointment_date" "ticket_id" "analysis_report" "result_id" "certification_id" "temperature"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/healthcare/contract.py:23-24
    // # --- Participants ---
    // self.patient = GlobalState(
    bytec 20 // "patient"
    // smart_contracts/healthcare/contract.py:25
    // Account("R7R7MB4X6DC33BXAR5OKBTRMBLKO6JGDTSCBEHH523T2XGMCFW3JRN3D2M")
    pushbytes base32(R7R7MB4X6DC33BXAR5OKBTRMBLKO6JGDTSCBEHH523T2XGMCFW3A) // addr R7R7MB4X6DC33BXAR5OKBTRMBLKO6JGDTSCBEHH523T2XGMCFW3JRN3D2M
    // smart_contracts/healthcare/contract.py:23-26
    // # --- Participants ---
    // self.patient = GlobalState(
    //     Account("R7R7MB4X6DC33BXAR5OKBTRMBLKO6JGDTSCBEHH523T2XGMCFW3JRN3D2M")
    // )
    app_global_put
    // smart_contracts/healthcare/contract.py:27
    // self.radiology = GlobalState(
    bytec 21 // "radiology"
    // smart_contracts/healthcare/contract.py:28
    // Account("GPG6DUODJFQ4TQTECLCI36JMBKOXOKY56HZSNQ6PQTLTOI4XFWHSNPK4LQ")
    pushbytes base32(GPG6DUODJFQ4TQTECLCI36JMBKOXOKY56HZSNQ6PQTLTOI4XFWHQ) // addr GPG6DUODJFQ4TQTECLCI36JMBKOXOKY56HZSNQ6PQTLTOI4XFWHSNPK4LQ
    // smart_contracts/healthcare/contract.py:27-29
    // self.radiology = GlobalState(
    //     Account("GPG6DUODJFQ4TQTECLCI36JMBKOXOKY56HZSNQ6PQTLTOI4XFWHSNPK4LQ")
    // )
    app_global_put
    // smart_contracts/healthcare/contract.py:30
    // self.ward = GlobalState(
    bytec 23 // "ward"
    // smart_contracts/healthcare/contract.py:31
    // Account("5632N7QYG2DLUUSDD227YUFTOKR56NVU7KHXALUQT5EUU42IJFVSW6DNHU")
    pushbytes base32(5632N7QYG2DLUUSDD227YUFTOKR56NVU7KHXALUQT5EUU42IJFVQ) // addr 5632N7QYG2DLUUSDD227YUFTOKR56NVU7KHXALUQT5EUU42IJFVSW6DNHU
    // smart_contracts/healthcare/contract.py:30-32
    // self.ward = GlobalState(
    //     Account("5632N7QYG2DLUUSDD227YUFTOKR56NVU7KHXALUQT5EUU42IJFVSW6DNHU")
    // )
    app_global_put
    // smart_contracts/healthcare/contract.py:37-38
    // # --- BASIC edges (e0-e12 - UNCHANGED from Figure 1) ---
    // self.e0 = GlobalState(UInt64(1))  # start event
    bytec 11 // "e0"
    intc_1 // 1
    app_global_put
    // smart_contracts/healthcare/contract.py:39
    // self.e1 = GlobalState(UInt64(0))  # after appointment message sent
    bytec_2 // "e1"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:40
    // self.e2 = GlobalState(UInt64(0))  # after request sent to ward
    bytec 12 // "e2"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:41
    // self.e3 = GlobalState(UInt64(0))  # after ward response
    bytec_3 // "e3"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:42
    // self.e4 = GlobalState(UInt64(0))  # accepted==true path
    bytec 13 // "e4"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:43
    // self.e5 = GlobalState(UInt64(0))  # accepted==false path (loop back)
    bytec 4 // "e5"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:44
    // self.e6 = GlobalState(UInt64(0))  # after registration message sent
    bytec 27 // "e6"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:45
    // self.e7 = GlobalState(UInt64(0))  # after checkin message sent
    bytec 14 // "e7"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:46
    // self.e8 = GlobalState(UInt64(0))  # after confirmation message sent
    bytec 5 // "e8"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:47
    // self.e9 = GlobalState(UInt64(0))  # registration==true path
    bytec 15 // "e9"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:48
    // self.e10 = GlobalState(UInt64(0))  # registration==false path (end)
    bytec 6 // "e10"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:49
    // self.e11 = GlobalState(UInt64(0))  # after analysis sent to ward
    bytec 16 // "e11"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:50
    // self.e12 = GlobalState(UInt64(0))  # after send_results (end success)
    bytec 7 // "e12"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:52-53
    // # --- NEW edges (e13-e18 for parallel gateway) ---
    // self.e13 = GlobalState(UInt64(0))
    bytec 8 // "e13"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:54
    // self.e14 = GlobalState(UInt64(0))
    bytec 17 // "e14"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:55
    // self.e15 = GlobalState(UInt64(0))
    bytec 18 // "e15"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:56
    // self.e16 = GlobalState(UInt64(0))
    bytec 9 // "e16"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:57
    // self.e17 = GlobalState(UInt64(0))
    bytec 10 // "e17"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:58
    // self.e18 = GlobalState(UInt64(0))
    bytec 19 // "e18"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:60
    // self.locked = GlobalState(UInt64(0))
    bytec_0 // "locked"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:62-63
    // # --- BASIC Data Objects ---
    // self.medical_prescription = GlobalState(String(""))
    bytec 28 // "medical_prescription"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:64
    // self.request_id = GlobalState(String(""))
    bytec 29 // "request_id"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:65
    // self.accepted = GlobalState(UInt64(0))
    bytec 24 // "accepted"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:66
    // self.appointment_date = GlobalState(String(""))
    bytec 30 // "appointment_date"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:67
    // self.appointment_id = GlobalState(String(""))
    bytec 25 // "appointment_id"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:68
    // self.registration_confirmed = GlobalState(UInt64(0))
    bytec 26 // "registration_confirmed"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:69
    // self.ticket_id = GlobalState(String(""))
    bytec 31 // "ticket_id"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:70
    // self.analysis_report = GlobalState(String(""))
    bytec 32 // "analysis_report"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:71
    // self.result_id = GlobalState(String(""))
    bytec 33 // "result_id"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:73-74
    // # --- NEW Data Objects ---
    // self.certification_id = GlobalState(String(""))
    bytec 34 // "certification_id"
    bytec_1 // ""
    app_global_put
    // smart_contracts/healthcare/contract.py:75
    // self.temperature = GlobalState(String(""))
    bytec 35 // "temperature"
    bytec_1 // ""
    app_global_put

main_after_if_else@2:
    // smart_contracts/healthcare/contract.py:21
    // class healthcare(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@23
    pushbytes 0x24378d3c // method "delete()void"
    txna ApplicationArgs 0
    match main_delete_route@5

main_switch_case_next@6:
    // smart_contracts/healthcare/contract.py:21
    // class healthcare(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0xccf37f8b 0x9d6516c1 0xe5251111 0x5db0b310 0xd0ba0609 0x004cf389 0x1a1b2603 0x83c80b9c 0x491b8119 0x1d68e812 0xff28c81d 0x702d613f // method "execute()uint64", method "take_appointment(string)void", method "check_availability(string)void", method "send_availability(uint64,string)void", method "confirm_appointment(string)void", method "check_certification(string)void", method "check_temperature(string)void", method "checkin(string)void", method "checkin_confirmation(uint64)void", method "xray_analysis(string,string)void", method "xray_report(string)void", method "unlock()void"
    txna ApplicationArgs 0
    match execute take_appointment check_availability send_availability confirm_appointment check_certification check_temperature checkin checkin_confirmation xray_analysis xray_report unlock
    err

main_delete_route@5:
    // smart_contracts/healthcare/contract.py:369
    // @abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert
    b delete

main_bare_routing@23:
    // smart_contracts/healthcare/contract.py:21
    // class healthcare(ARC4Contract):
    intc_0 // NoOp
    pushint 4 // UpdateApplication
    txn OnCompletion
    match main_create@24 main_update@25
    err

main_update@25:
    // smart_contracts/healthcare/contract.py:357
    // @baremethod(allow_actions=["UpdateApplication"])
    txn ApplicationID
    assert
    // smart_contracts/healthcare/contract.py:359
    // assert Txn.sender == self.admin.value, "Only admin"
    txn Sender
    intc_0 // 0
    bytec 22 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin
    // smart_contracts/healthcare/contract.py:360
    // self.locked.value = UInt64(1)
    bytec_0 // "locked"
    intc_1 // 1
    app_global_put
    // smart_contracts/healthcare/contract.py:361
    // log(Bytes(b"Locked for update"))
    pushbytes 0x4c6f636b656420666f7220757064617465
    log
    // smart_contracts/healthcare/contract.py:357
    // @baremethod(allow_actions=["UpdateApplication"])
    intc_1 // 1
    return

main_create@24:
    // smart_contracts/healthcare/contract.py:79
    // self.admin.value = Txn.sender
    bytec 22 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/healthcare/contract.py:80
    // self.e0.value = UInt64(1)
    bytec 11 // "e0"
    intc_1 // 1
    app_global_put
    // smart_contracts/healthcare/contract.py:81
    // self.locked.value = UInt64(0)
    bytec_0 // "locked"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:82
    // log(Bytes(b"RadiologyUpgraded deployed"))
    pushbytes 0x526164696f6c6f67795570677261646564206465706c6f796564
    log
    // smart_contracts/healthcare/contract.py:77
    // @baremethod(create="allow")
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.execute[routing]() -> void:
execute:
    // smart_contracts/healthcare/contract.py:186
    // @abimethod
    callsub smart_contracts.healthcare.contract.healthcare.execute
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.take_appointment[routing]() -> void:
take_appointment:
    // smart_contracts/healthcare/contract.py:224
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:227
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:228
    // assert self.e1.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec_2 // "e1"
    app_global_get_ex
    assert // check self.e1 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:229
    // assert Txn.sender == self.patient.value, "Only patient"
    txn Sender
    intc_0 // 0
    bytec 20 // "patient"
    app_global_get_ex
    assert // check self.patient exists
    ==
    assert // Only patient
    // smart_contracts/healthcare/contract.py:231
    // self.e1.value -= UInt64(1)
    intc_1 // 1
    -
    bytec_2 // "e1"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:232
    // self.medical_prescription.value = medical_prescription
    bytec 28 // "medical_prescription"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:233
    // self.e2.value += UInt64(1)
    intc_0 // 0
    bytec 12 // "e2"
    app_global_get_ex
    assert // check self.e2 exists
    intc_1 // 1
    +
    bytec 12 // "e2"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:234
    // log(Bytes(b"Patient->Radiology: appointment"))
    pushbytes 0x50617469656e742d3e526164696f6c6f67793a206170706f696e746d656e74
    log
    // smart_contracts/healthcare/contract.py:224
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.check_availability[routing]() -> void:
check_availability:
    // smart_contracts/healthcare/contract.py:236
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:239
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:240
    // assert self.e2.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 12 // "e2"
    app_global_get_ex
    assert // check self.e2 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:241
    // assert Txn.sender == self.radiology.value, "Only radiology"
    txn Sender
    intc_0 // 0
    bytec 21 // "radiology"
    app_global_get_ex
    assert // check self.radiology exists
    ==
    assert // Only radiology
    // smart_contracts/healthcare/contract.py:243
    // self.e2.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 12 // "e2"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:244
    // self.request_id.value = request_id
    bytec 29 // "request_id"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:245
    // self.e3.value += UInt64(1)
    intc_0 // 0
    bytec_3 // "e3"
    app_global_get_ex
    assert // check self.e3 exists
    intc_1 // 1
    +
    bytec_3 // "e3"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:246
    // log(Bytes(b"Radiology->ward: request"))
    pushbytes 0x526164696f6c6f67792d3e776172643a2072657175657374
    log
    // smart_contracts/healthcare/contract.py:236
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.send_availability[routing]() -> void:
send_availability:
    // smart_contracts/healthcare/contract.py:248
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:251
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:252
    // assert self.e3.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec_3 // "e3"
    app_global_get_ex
    assert // check self.e3 exists
    assert // Task not active
    // smart_contracts/healthcare/contract.py:253
    // assert Txn.sender == self.ward.value, "Only ward"
    txn Sender
    intc_0 // 0
    bytec 23 // "ward"
    app_global_get_ex
    assert // check self.ward exists
    ==
    assert // Only ward
    // smart_contracts/healthcare/contract.py:255
    // self.accepted.value = accepted
    bytec 24 // "accepted"
    uncover 2
    app_global_put
    // smart_contracts/healthcare/contract.py:256
    // self.appointment_date.value = date
    bytec 30 // "appointment_date"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:257
    // log(Bytes(b"ward->Radiology: response"))
    pushbytes 0x776172642d3e526164696f6c6f67793a20726573706f6e7365
    log
    // smart_contracts/healthcare/contract.py:258
    // self.execute()
    callsub smart_contracts.healthcare.contract.healthcare.execute
    pop
    // smart_contracts/healthcare/contract.py:248
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.confirm_appointment[routing]() -> void:
confirm_appointment:
    // smart_contracts/healthcare/contract.py:260
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:263
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:264
    // assert self.e4.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 13 // "e4"
    app_global_get_ex
    assert // check self.e4 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:265
    // assert Txn.sender == self.radiology.value, "Only radiology"
    txn Sender
    intc_0 // 0
    bytec 21 // "radiology"
    app_global_get_ex
    assert // check self.radiology exists
    ==
    assert // Only radiology
    // smart_contracts/healthcare/contract.py:267
    // self.e4.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 13 // "e4"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:268
    // self.appointment_id.value = appointment_id
    bytec 25 // "appointment_id"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:269-270
    // # CHANGED: Now triggers parallel gateway instead of going to e6
    // self.e13.value += UInt64(1)
    intc_0 // 0
    bytec 8 // "e13"
    app_global_get_ex
    assert // check self.e13 exists
    intc_1 // 1
    +
    bytec 8 // "e13"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:271
    // log(Bytes(b"Radiology->Patient: registration"))
    pushbytes 0x526164696f6c6f67792d3e50617469656e743a20726567697374726174696f6e
    log
    // smart_contracts/healthcare/contract.py:272
    // self.execute()
    callsub smart_contracts.healthcare.contract.healthcare.execute
    pop
    // smart_contracts/healthcare/contract.py:260
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.check_certification[routing]() -> void:
check_certification:
    // smart_contracts/healthcare/contract.py:276
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:279
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:280
    // assert self.e14.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 17 // "e14"
    app_global_get_ex
    assert // check self.e14 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:281
    // assert Txn.sender == self.patient.value, "Only patient"
    txn Sender
    intc_0 // 0
    bytec 20 // "patient"
    app_global_get_ex
    assert // check self.patient exists
    ==
    assert // Only patient
    // smart_contracts/healthcare/contract.py:283
    // self.e14.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 17 // "e14"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:284
    // self.certification_id.value = certification_id
    bytec 34 // "certification_id"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:285
    // self.e16.value += UInt64(1)
    intc_0 // 0
    bytec 9 // "e16"
    app_global_get_ex
    assert // check self.e16 exists
    intc_1 // 1
    +
    bytec 9 // "e16"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:286
    // log(Bytes(b"Patient->Radiology: certification"))
    pushbytes 0x50617469656e742d3e526164696f6c6f67793a2063657274696669636174696f6e
    log
    // smart_contracts/healthcare/contract.py:287
    // self.execute()
    callsub smart_contracts.healthcare.contract.healthcare.execute
    pop
    // smart_contracts/healthcare/contract.py:276
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.check_temperature[routing]() -> void:
check_temperature:
    // smart_contracts/healthcare/contract.py:289
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:292
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:293
    // assert self.e15.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 18 // "e15"
    app_global_get_ex
    assert // check self.e15 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:294
    // assert Txn.sender == self.patient.value, "Only patient"
    txn Sender
    intc_0 // 0
    bytec 20 // "patient"
    app_global_get_ex
    assert // check self.patient exists
    ==
    assert // Only patient
    // smart_contracts/healthcare/contract.py:296
    // self.e15.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 18 // "e15"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:297
    // self.temperature.value = temperature
    bytec 35 // "temperature"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:298
    // self.e17.value += UInt64(1)
    intc_0 // 0
    bytec 10 // "e17"
    app_global_get_ex
    assert // check self.e17 exists
    intc_1 // 1
    +
    bytec 10 // "e17"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:299
    // log(Bytes(b"Patient->Radiology: temperature"))
    pushbytes 0x50617469656e742d3e526164696f6c6f67793a2074656d7065726174757265
    log
    // smart_contracts/healthcare/contract.py:300
    // self.execute()
    callsub smart_contracts.healthcare.contract.healthcare.execute
    pop
    // smart_contracts/healthcare/contract.py:289
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.checkin[routing]() -> void:
checkin:
    // smart_contracts/healthcare/contract.py:304
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:307
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:308
    // assert self.e18.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 19 // "e18"
    app_global_get_ex
    assert // check self.e18 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:309
    // assert Txn.sender == self.patient.value, "Only patient"
    txn Sender
    intc_0 // 0
    bytec 20 // "patient"
    app_global_get_ex
    assert // check self.patient exists
    ==
    assert // Only patient
    // smart_contracts/healthcare/contract.py:310
    // assert appointment_id == self.appointment_id.value, "ID mismatch"
    intc_0 // 0
    bytec 25 // "appointment_id"
    app_global_get_ex
    assert // check self.appointment_id exists
    uncover 2
    ==
    assert // ID mismatch
    // smart_contracts/healthcare/contract.py:312
    // self.e18.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 19 // "e18"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:313
    // self.e7.value += UInt64(1)
    intc_0 // 0
    bytec 14 // "e7"
    app_global_get_ex
    assert // check self.e7 exists
    intc_1 // 1
    +
    bytec 14 // "e7"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:314
    // log(Bytes(b"Patient->Radiology: checkin"))
    pushbytes 0x50617469656e742d3e526164696f6c6f67793a20636865636b696e
    log
    // smart_contracts/healthcare/contract.py:304
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.checkin_confirmation[routing]() -> void:
checkin_confirmation:
    // smart_contracts/healthcare/contract.py:316
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/healthcare/contract.py:319
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:320
    // assert self.e7.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 14 // "e7"
    app_global_get_ex
    assert // check self.e7 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:321
    // assert Txn.sender == self.radiology.value, "Only radiology"
    txn Sender
    intc_0 // 0
    bytec 21 // "radiology"
    app_global_get_ex
    assert // check self.radiology exists
    ==
    assert // Only radiology
    // smart_contracts/healthcare/contract.py:323
    // self.e7.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 14 // "e7"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:324
    // self.registration_confirmed.value = registration_confirmed
    bytec 26 // "registration_confirmed"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:325
    // self.e8.value += UInt64(1)
    intc_0 // 0
    bytec 5 // "e8"
    app_global_get_ex
    assert // check self.e8 exists
    intc_1 // 1
    +
    bytec 5 // "e8"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:326
    // log(Bytes(b"Radiology->Patient: confirmation"))
    pushbytes 0x526164696f6c6f67792d3e50617469656e743a20636f6e6669726d6174696f6e
    log
    // smart_contracts/healthcare/contract.py:327
    // self.execute()
    callsub smart_contracts.healthcare.contract.healthcare.execute
    pop
    // smart_contracts/healthcare/contract.py:316
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.xray_analysis[routing]() -> void:
xray_analysis:
    // smart_contracts/healthcare/contract.py:329
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:332
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:333
    // assert self.e9.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 15 // "e9"
    app_global_get_ex
    assert // check self.e9 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:334
    // assert Txn.sender == self.radiology.value, "Only radiology"
    txn Sender
    intc_0 // 0
    bytec 21 // "radiology"
    app_global_get_ex
    assert // check self.radiology exists
    ==
    assert // Only radiology
    // smart_contracts/healthcare/contract.py:336
    // self.e9.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 15 // "e9"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:337
    // self.ticket_id.value = ticket_id
    bytec 31 // "ticket_id"
    uncover 2
    app_global_put
    // smart_contracts/healthcare/contract.py:338
    // self.analysis_report.value = report
    bytec 32 // "analysis_report"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:339
    // self.e11.value += UInt64(1)
    intc_0 // 0
    bytec 16 // "e11"
    app_global_get_ex
    assert // check self.e11 exists
    intc_1 // 1
    +
    bytec 16 // "e11"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:340
    // log(Bytes(b"Radiology->ward: analysis"))
    pushbytes 0x526164696f6c6f67792d3e776172643a20616e616c79736973
    log
    // smart_contracts/healthcare/contract.py:329
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.xray_report[routing]() -> void:
xray_report:
    // smart_contracts/healthcare/contract.py:342
    // @abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/healthcare/contract.py:345
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:346
    // assert self.e11.value > UInt64(0), "Task not active"
    intc_0 // 0
    bytec 16 // "e11"
    app_global_get_ex
    assert // check self.e11 exists
    dup
    assert // Task not active
    // smart_contracts/healthcare/contract.py:347
    // assert Txn.sender == self.ward.value, "Only ward"
    txn Sender
    intc_0 // 0
    bytec 23 // "ward"
    app_global_get_ex
    assert // check self.ward exists
    ==
    assert // Only ward
    // smart_contracts/healthcare/contract.py:349
    // self.e11.value -= UInt64(1)
    intc_1 // 1
    -
    bytec 16 // "e11"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:350
    // self.result_id.value = result_id
    bytec 33 // "result_id"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:351
    // self.e12.value += UInt64(1)
    intc_0 // 0
    bytec 7 // "e12"
    app_global_get_ex
    assert // check self.e12 exists
    intc_1 // 1
    +
    bytec 7 // "e12"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:352
    // log(Bytes(b"ward->Patient: report"))
    pushbytes 0x776172642d3e50617469656e743a207265706f7274
    log
    // smart_contracts/healthcare/contract.py:353
    // self.execute()
    callsub smart_contracts.healthcare.contract.healthcare.execute
    pop
    // smart_contracts/healthcare/contract.py:342
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.unlock[routing]() -> void:
unlock:
    // smart_contracts/healthcare/contract.py:365
    // assert Txn.sender == self.admin.value, "Only admin"
    txn Sender
    intc_0 // 0
    bytec 22 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin
    // smart_contracts/healthcare/contract.py:366
    // self.locked.value = UInt64(0)
    bytec_0 // "locked"
    intc_0 // 0
    app_global_put
    // smart_contracts/healthcare/contract.py:367
    // log(Bytes(b"Unlocked"))
    pushbytes 0x556e6c6f636b6564
    log
    // smart_contracts/healthcare/contract.py:363
    // @abimethod
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.delete[routing]() -> void:
delete:
    // smart_contracts/healthcare/contract.py:371
    // assert Txn.sender == self.admin.value, "Only admin"
    txn Sender
    intc_0 // 0
    bytec 22 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin
    // smart_contracts/healthcare/contract.py:372
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:373
    // log(Bytes(b"Deleted"))
    pushbytes 0x44656c65746564
    log
    // smart_contracts/healthcare/contract.py:369
    // @abimethod(allow_actions=["DeleteApplication"])
    intc_1 // 1
    return


// smart_contracts.healthcare.contract.healthcare.execute() -> uint64:
smart_contracts.healthcare.contract.healthcare.execute:
    // smart_contracts/healthcare/contract.py:188
    // assert self.locked.value == UInt64(0), "Contract is locked"
    intc_0 // 0
    bytec_0 // "locked"
    app_global_get_ex
    assert // check self.locked exists
    !
    assert // Contract is locked
    // smart_contracts/healthcare/contract.py:189
    // executed = True
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_while_top@1:
    // smart_contracts/healthcare/contract.py:190
    // while executed:
    bz smart_contracts.healthcare.contract.healthcare.execute_after_while@3
    // smart_contracts/healthcare/contract.py:88
    // if self.e0.value > UInt64(0):
    intc_0 // 0
    bytec 11 // "e0"
    app_global_get_ex
    assert // check self.e0 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@9
    // smart_contracts/healthcare/contract.py:89
    // self.e0.value -= UInt64(1)
    intc_0 // 0
    bytec 11 // "e0"
    app_global_get_ex
    assert // check self.e0 exists
    intc_1 // 1
    -
    bytec 11 // "e0"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:90
    // self.e1.value += UInt64(1)
    intc_0 // 0
    bytec_2 // "e1"
    app_global_get_ex
    assert // check self.e1 exists
    intc_1 // 1
    +
    bytec_2 // "e1"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:91
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.start_event@10:
    // smart_contracts/healthcare/contract.py:168
    // if self.start_event() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@12
    // smart_contracts/healthcare/contract.py:169
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55:
    // smart_contracts/healthcare/contract.py:192
    // executed = rule_executed != UInt64(0)
    intc_0 // 0
    !=
    b smart_contracts.healthcare.contract.healthcare.execute_while_top@1

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@12:
    // smart_contracts/healthcare/contract.py:96
    // if self.e3.value > UInt64(0):
    intc_0 // 0
    bytec_3 // "e3"
    app_global_get_ex
    assert // check self.e3 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@17
    // smart_contracts/healthcare/contract.py:97
    // self.e3.value -= UInt64(1)
    intc_0 // 0
    bytec_3 // "e3"
    app_global_get_ex
    assert // check self.e3 exists
    intc_1 // 1
    -
    bytec_3 // "e3"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:98
    // if self.accepted.value == UInt64(0):
    intc_0 // 0
    bytec 24 // "accepted"
    app_global_get_ex
    assert // check self.accepted exists
    bnz smart_contracts.healthcare.contract.healthcare.execute_else_body@15
    // smart_contracts/healthcare/contract.py:99
    // self.e5.value += UInt64(1)
    intc_0 // 0
    bytec 4 // "e5"
    app_global_get_ex
    assert // check self.e5 exists
    intc_1 // 1
    +
    bytec 4 // "e5"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:100
    // log(Bytes(b"XOR: accepted==false"))
    pushbytes 0x584f523a2061636365707465643d3d66616c7365
    log

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@16:
    // smart_contracts/healthcare/contract.py:104
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.xor1_availability_check@18:
    // smart_contracts/healthcare/contract.py:170
    // if self.xor1_availability_check() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@20
    // smart_contracts/healthcare/contract.py:171
    // return UInt64(1)
    intc_1 // 1
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@20:
    // smart_contracts/healthcare/contract.py:109
    // if self.e5.value > UInt64(0):
    intc_0 // 0
    bytec 4 // "e5"
    app_global_get_ex
    assert // check self.e5 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@22
    // smart_contracts/healthcare/contract.py:110
    // self.e5.value -= UInt64(1)
    intc_0 // 0
    bytec 4 // "e5"
    app_global_get_ex
    assert // check self.e5 exists
    intc_1 // 1
    -
    bytec 4 // "e5"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:111
    // self.e1.value += UInt64(1)
    intc_0 // 0
    bytec_2 // "e1"
    app_global_get_ex
    assert // check self.e1 exists
    intc_1 // 1
    +
    bytec_2 // "e1"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:112
    // log(Bytes(b"Loop back"))
    pushbytes 0x4c6f6f70206261636b
    log
    // smart_contracts/healthcare/contract.py:113
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.xor2_loop_back@23:
    // smart_contracts/healthcare/contract.py:172
    // if self.xor2_loop_back() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@25
    // smart_contracts/healthcare/contract.py:173
    // return UInt64(1)
    intc_1 // 1
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@25:
    // smart_contracts/healthcare/contract.py:119
    // if self.e13.value > UInt64(0):
    intc_0 // 0
    bytec 8 // "e13"
    app_global_get_ex
    assert // check self.e13 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@27
    // smart_contracts/healthcare/contract.py:120
    // self.e13.value -= UInt64(1)
    intc_0 // 0
    bytec 8 // "e13"
    app_global_get_ex
    assert // check self.e13 exists
    intc_1 // 1
    -
    bytec 8 // "e13"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:121
    // self.e14.value += UInt64(1)  # certification
    intc_0 // 0
    bytec 17 // "e14"
    app_global_get_ex
    assert // check self.e14 exists
    intc_1 // 1
    +
    bytec 17 // "e14"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:122
    // self.e15.value += UInt64(1)  # temperature
    intc_0 // 0
    bytec 18 // "e15"
    app_global_get_ex
    assert // check self.e15 exists
    intc_1 // 1
    +
    bytec 18 // "e15"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:123
    // log(Bytes(b"Parallel split"))
    pushbytes 0x506172616c6c656c2073706c6974
    log
    // smart_contracts/healthcare/contract.py:124
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.parallel_split@28:
    // smart_contracts/healthcare/contract.py:174
    // if self.parallel_split() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@30
    // smart_contracts/healthcare/contract.py:175
    // return UInt64(1)
    intc_1 // 1
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@30:
    // smart_contracts/healthcare/contract.py:129
    // if self.e16.value > UInt64(0) and self.e17.value > UInt64(0):
    intc_0 // 0
    bytec 9 // "e16"
    app_global_get_ex
    assert // check self.e16 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@33
    intc_0 // 0
    bytec 10 // "e17"
    app_global_get_ex
    assert // check self.e17 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@33
    // smart_contracts/healthcare/contract.py:130
    // self.e16.value -= UInt64(1)
    intc_0 // 0
    bytec 9 // "e16"
    app_global_get_ex
    assert // check self.e16 exists
    intc_1 // 1
    -
    bytec 9 // "e16"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:131
    // self.e17.value -= UInt64(1)
    intc_0 // 0
    bytec 10 // "e17"
    app_global_get_ex
    assert // check self.e17 exists
    intc_1 // 1
    -
    bytec 10 // "e17"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:132
    // self.e18.value += UInt64(1)
    intc_0 // 0
    bytec 19 // "e18"
    app_global_get_ex
    assert // check self.e18 exists
    intc_1 // 1
    +
    bytec 19 // "e18"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:133
    // log(Bytes(b"Parallel join"))
    pushbytes 0x506172616c6c656c206a6f696e
    log
    // smart_contracts/healthcare/contract.py:134
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.parallel_join@34:
    // smart_contracts/healthcare/contract.py:176
    // if self.parallel_join() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@36
    // smart_contracts/healthcare/contract.py:177
    // return UInt64(1)
    intc_1 // 1
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@36:
    // smart_contracts/healthcare/contract.py:139
    // if self.e8.value > UInt64(0):
    intc_0 // 0
    bytec 5 // "e8"
    app_global_get_ex
    assert // check self.e8 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@41
    // smart_contracts/healthcare/contract.py:140
    // self.e8.value -= UInt64(1)
    intc_0 // 0
    bytec 5 // "e8"
    app_global_get_ex
    assert // check self.e8 exists
    intc_1 // 1
    -
    bytec 5 // "e8"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:141
    // if self.registration_confirmed.value == UInt64(1):
    intc_0 // 0
    bytec 26 // "registration_confirmed"
    app_global_get_ex
    assert // check self.registration_confirmed exists
    intc_1 // 1
    ==
    bz smart_contracts.healthcare.contract.healthcare.execute_else_body@39
    // smart_contracts/healthcare/contract.py:142
    // self.e9.value += UInt64(1)
    intc_0 // 0
    bytec 15 // "e9"
    app_global_get_ex
    assert // check self.e9 exists
    intc_1 // 1
    +
    bytec 15 // "e9"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:143
    // log(Bytes(b"XOR: registration==true"))
    pushbytes 0x584f523a20726567697374726174696f6e3d3d74727565
    log

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@40:
    // smart_contracts/healthcare/contract.py:147
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.xor3_registration_check@42:
    // smart_contracts/healthcare/contract.py:178
    // if self.xor3_registration_check() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@44
    // smart_contracts/healthcare/contract.py:179
    // return UInt64(1)
    intc_1 // 1
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@44:
    // smart_contracts/healthcare/contract.py:152
    // if self.e12.value > UInt64(0):
    intc_0 // 0
    bytec 7 // "e12"
    app_global_get_ex
    assert // check self.e12 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@46
    // smart_contracts/healthcare/contract.py:153
    // self.e12.value -= UInt64(1)
    intc_0 // 0
    bytec 7 // "e12"
    app_global_get_ex
    assert // check self.e12 exists
    intc_1 // 1
    -
    bytec 7 // "e12"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:154
    // log(Bytes(b"Completed: success"))
    pushbytes 0x436f6d706c657465643a2073756363657373
    log
    // smart_contracts/healthcare/contract.py:155
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.end_success@47:
    // smart_contracts/healthcare/contract.py:180
    // if self.end_success() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@49
    // smart_contracts/healthcare/contract.py:181
    // return UInt64(1)
    intc_1 // 1
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@49:
    // smart_contracts/healthcare/contract.py:160
    // if self.e10.value > UInt64(0):
    intc_0 // 0
    bytec 6 // "e10"
    app_global_get_ex
    assert // check self.e10 exists
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@51
    // smart_contracts/healthcare/contract.py:161
    // self.e10.value -= UInt64(1)
    intc_0 // 0
    bytec 6 // "e10"
    app_global_get_ex
    assert // check self.e10 exists
    intc_1 // 1
    -
    bytec 6 // "e10"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:162
    // log(Bytes(b"Completed: reject"))
    pushbytes 0x436f6d706c657465643a2072656a656374
    log
    // smart_contracts/healthcare/contract.py:163
    // return UInt64(1)
    intc_1 // 1

smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.end_reject@52:
    // smart_contracts/healthcare/contract.py:182
    // if self.end_reject() != UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_after_if_else@54
    // smart_contracts/healthcare/contract.py:183
    // return UInt64(1)
    intc_1 // 1
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@54:
    // smart_contracts/healthcare/contract.py:184
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:191
    // rule_executed = self.execute_one_rule()
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.execute_one_rule@55

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@51:
    // smart_contracts/healthcare/contract.py:164
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:182
    // if self.end_reject() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.end_reject@52

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@46:
    // smart_contracts/healthcare/contract.py:156
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:180
    // if self.end_success() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.end_success@47

smart_contracts.healthcare.contract.healthcare.execute_else_body@39:
    // smart_contracts/healthcare/contract.py:145
    // self.e10.value += UInt64(1)
    intc_0 // 0
    bytec 6 // "e10"
    app_global_get_ex
    assert // check self.e10 exists
    intc_1 // 1
    +
    bytec 6 // "e10"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:146
    // log(Bytes(b"XOR: registration==false"))
    pushbytes 0x584f523a20726567697374726174696f6e3d3d66616c7365
    log
    b smart_contracts.healthcare.contract.healthcare.execute_after_if_else@40

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@41:
    // smart_contracts/healthcare/contract.py:148
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:178
    // if self.xor3_registration_check() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.xor3_registration_check@42

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@33:
    // smart_contracts/healthcare/contract.py:135
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:176
    // if self.parallel_join() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.parallel_join@34

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@27:
    // smart_contracts/healthcare/contract.py:125
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:174
    // if self.parallel_split() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.parallel_split@28

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@22:
    // smart_contracts/healthcare/contract.py:114
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:172
    // if self.xor2_loop_back() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.xor2_loop_back@23

smart_contracts.healthcare.contract.healthcare.execute_else_body@15:
    // smart_contracts/healthcare/contract.py:102
    // self.e4.value += UInt64(1)
    intc_0 // 0
    bytec 13 // "e4"
    app_global_get_ex
    assert // check self.e4 exists
    intc_1 // 1
    +
    bytec 13 // "e4"
    swap
    app_global_put
    // smart_contracts/healthcare/contract.py:103
    // log(Bytes(b"XOR: accepted==true"))
    pushbytes 0x584f523a2061636365707465643d3d74727565
    log
    b smart_contracts.healthcare.contract.healthcare.execute_after_if_else@16

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@17:
    // smart_contracts/healthcare/contract.py:105
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:170
    // if self.xor1_availability_check() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.xor1_availability_check@18

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@9:
    // smart_contracts/healthcare/contract.py:92
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/healthcare/contract.py:168
    // if self.start_event() != UInt64(0):
    b smart_contracts.healthcare.contract.healthcare.execute_after_inlined_smart_contracts.healthcare.contract.healthcare.start_event@10

smart_contracts.healthcare.contract.healthcare.execute_after_while@3:
    // smart_contracts/healthcare/contract.py:195
    // self.e0.value
    intc_0 // 0
    bytec 11 // "e0"
    app_global_get_ex
    assert // check self.e0 exists
    // smart_contracts/healthcare/contract.py:196
    // + self.e1.value
    intc_0 // 0
    bytec_2 // "e1"
    app_global_get_ex
    assert // check self.e1 exists
    // smart_contracts/healthcare/contract.py:195-196
    // self.e0.value
    // + self.e1.value
    +
    // smart_contracts/healthcare/contract.py:197
    // + self.e2.value
    intc_0 // 0
    bytec 12 // "e2"
    app_global_get_ex
    assert // check self.e2 exists
    // smart_contracts/healthcare/contract.py:195-197
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    +
    // smart_contracts/healthcare/contract.py:198
    // + self.e3.value
    intc_0 // 0
    bytec_3 // "e3"
    app_global_get_ex
    assert // check self.e3 exists
    // smart_contracts/healthcare/contract.py:195-198
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    +
    // smart_contracts/healthcare/contract.py:199
    // + self.e4.value
    intc_0 // 0
    bytec 13 // "e4"
    app_global_get_ex
    assert // check self.e4 exists
    // smart_contracts/healthcare/contract.py:195-199
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    +
    // smart_contracts/healthcare/contract.py:200
    // + self.e5.value
    intc_0 // 0
    bytec 4 // "e5"
    app_global_get_ex
    assert // check self.e5 exists
    // smart_contracts/healthcare/contract.py:195-200
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    +
    // smart_contracts/healthcare/contract.py:201
    // + self.e6.value
    intc_0 // 0
    bytec 27 // "e6"
    app_global_get_ex
    assert // check self.e6 exists
    // smart_contracts/healthcare/contract.py:195-201
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    +
    // smart_contracts/healthcare/contract.py:202
    // + self.e7.value
    intc_0 // 0
    bytec 14 // "e7"
    app_global_get_ex
    assert // check self.e7 exists
    // smart_contracts/healthcare/contract.py:195-202
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    +
    // smart_contracts/healthcare/contract.py:203
    // + self.e8.value
    intc_0 // 0
    bytec 5 // "e8"
    app_global_get_ex
    assert // check self.e8 exists
    // smart_contracts/healthcare/contract.py:195-203
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    +
    // smart_contracts/healthcare/contract.py:204
    // + self.e9.value
    intc_0 // 0
    bytec 15 // "e9"
    app_global_get_ex
    assert // check self.e9 exists
    // smart_contracts/healthcare/contract.py:195-204
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    +
    // smart_contracts/healthcare/contract.py:205
    // + self.e10.value
    intc_0 // 0
    bytec 6 // "e10"
    app_global_get_ex
    assert // check self.e10 exists
    // smart_contracts/healthcare/contract.py:195-205
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    +
    // smart_contracts/healthcare/contract.py:206
    // + self.e11.value
    intc_0 // 0
    bytec 16 // "e11"
    app_global_get_ex
    assert // check self.e11 exists
    // smart_contracts/healthcare/contract.py:195-206
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    +
    // smart_contracts/healthcare/contract.py:207
    // + self.e12.value
    intc_0 // 0
    bytec 7 // "e12"
    app_global_get_ex
    assert // check self.e12 exists
    // smart_contracts/healthcare/contract.py:195-207
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    // + self.e12.value
    +
    // smart_contracts/healthcare/contract.py:208
    // + self.e13.value
    intc_0 // 0
    bytec 8 // "e13"
    app_global_get_ex
    assert // check self.e13 exists
    // smart_contracts/healthcare/contract.py:195-208
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    // + self.e12.value
    // + self.e13.value
    +
    // smart_contracts/healthcare/contract.py:209
    // + self.e14.value
    intc_0 // 0
    bytec 17 // "e14"
    app_global_get_ex
    assert // check self.e14 exists
    // smart_contracts/healthcare/contract.py:195-209
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    // + self.e12.value
    // + self.e13.value
    // + self.e14.value
    +
    // smart_contracts/healthcare/contract.py:210
    // + self.e15.value
    intc_0 // 0
    bytec 18 // "e15"
    app_global_get_ex
    assert // check self.e15 exists
    // smart_contracts/healthcare/contract.py:195-210
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    // + self.e12.value
    // + self.e13.value
    // + self.e14.value
    // + self.e15.value
    +
    // smart_contracts/healthcare/contract.py:211
    // + self.e16.value
    intc_0 // 0
    bytec 9 // "e16"
    app_global_get_ex
    assert // check self.e16 exists
    // smart_contracts/healthcare/contract.py:195-211
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    // + self.e12.value
    // + self.e13.value
    // + self.e14.value
    // + self.e15.value
    // + self.e16.value
    +
    // smart_contracts/healthcare/contract.py:212
    // + self.e17.value
    intc_0 // 0
    bytec 10 // "e17"
    app_global_get_ex
    assert // check self.e17 exists
    // smart_contracts/healthcare/contract.py:195-212
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    // + self.e12.value
    // + self.e13.value
    // + self.e14.value
    // + self.e15.value
    // + self.e16.value
    // + self.e17.value
    +
    // smart_contracts/healthcare/contract.py:213
    // + self.e18.value
    intc_0 // 0
    bytec 19 // "e18"
    app_global_get_ex
    assert // check self.e18 exists
    // smart_contracts/healthcare/contract.py:195-213
    // self.e0.value
    // + self.e1.value
    // + self.e2.value
    // + self.e3.value
    // + self.e4.value
    // + self.e5.value
    // + self.e6.value
    // + self.e7.value
    // + self.e8.value
    // + self.e9.value
    // + self.e10.value
    // + self.e11.value
    // + self.e12.value
    // + self.e13.value
    // + self.e14.value
    // + self.e15.value
    // + self.e16.value
    // + self.e17.value
    // + self.e18.value
    +
    // smart_contracts/healthcare/contract.py:216
    // if total_tokens > UInt64(0):
    bz smart_contracts.healthcare.contract.healthcare.execute_else_body@5
    // smart_contracts/healthcare/contract.py:217
    // log(Bytes(b"RUNNING"))
    pushbytes 0x52554e4e494e47
    log

smart_contracts.healthcare.contract.healthcare.execute_after_if_else@6:
    // smart_contracts/healthcare/contract.py:220
    // return UInt64(1)
    intc_1 // 1
    retsub

smart_contracts.healthcare.contract.healthcare.execute_else_body@5:
    // smart_contracts/healthcare/contract.py:219
    // log(Bytes(b"COMPLETED"))
    pushbytes 0x434f4d504c45544544
    log
    b smart_contracts.healthcare.contract.healthcare.execute_after_if_else@6
